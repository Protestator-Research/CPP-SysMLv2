
// Generated from KerML.g4 by ANTLR 4.13.2

#pragma once


#include "antlr4-runtime.h"




class  KerMLLexer : public antlr4::Lexer {
public:
  enum {
    T__0 = 1, TYPED_BY = 2, SPECIALIZES = 3, SUBSETS = 4, REFERENCES = 5, 
    REDEFINES = 6, CONJUNGATES = 7, KEYWORD_ABOUT = 8, KEYWORD_ABSTRACT = 9, 
    KEYWORD_ALIAS = 10, KEYWORD_ALL = 11, KEYWORD_AND = 12, KEYWORD_AS = 13, 
    KEYWORD_ASSOC = 14, KEYWORD_BEHAVIOR = 15, KEYWORD_BINDING = 16, KEYWORD_BOOL = 17, 
    KEYWORD_BY = 18, KEYWORD_CHAINS = 19, KEYWORD_CLASS = 20, KEYWORD_CLASSIFIER = 21, 
    KEYWORD_COMMENT = 22, KEYWORD_COMPOSITE = 23, KEYWORD_CONJUGATE = 24, 
    KEYWORD_CONJUGATES = 25, KEYWORD_CONJUGATION = 26, KEYWORD_CONNECTOR = 27, 
    KEYWORD_DATATYPE = 28, KEYWORD_DEFAULT = 29, KEYWORD_DEPENDENCY = 30, 
    KEYWORD_DERIVED = 31, KEYWORD_DIFFERENCES = 32, KEYWORD_DISJOINING = 33, 
    KEYWORD_DISJOINT = 34, KEYWORD_DOC = 35, KEYWORD_ELSE = 36, KEYWORD_END = 37, 
    KEYWORD_EXPR = 38, KEYWORD_FALSE = 39, KEYWORD_FEATURE = 40, KEYWORD_FEATURED = 41, 
    KEYWORD_FEATURING = 42, KEYWORD_FILTER = 43, KEYWORD_FIRST = 44, KEYWORD_FLOW = 45, 
    KEYWORD_FOR = 46, KEYWORD_FROM = 47, KEYWORD_FUNCTION = 48, KEYWORD_HASTYPE = 49, 
    KEYWORD_IF = 50, KEYWORD_INTERSECTS = 51, KEYWORD_IMPLIES = 52, KEYWORD_IMPORT = 53, 
    KEYWORD_IN = 54, KEYWORD_INOUT = 55, KEYWORD_INTERACTION = 56, KEYWORD_INV = 57, 
    KEYWORD_INVERSE = 58, KEYWORD_INVERTING = 59, KEYWORD_ISTYPE = 60, KEYWORD_LANGUAGE = 61, 
    KEYWORD_MEMBER = 62, KEYWORD_METACLASS = 63, KEYWORD_METADATA = 64, 
    KEYWORD_MULTIPLICITY = 65, KEYWORD_NAMESPACE = 66, KEYWORD_NONUNIQUE = 67, 
    KEYWORD_NOT = 68, KEYWORD_NULL = 69, KEYWORD_OF = 70, KEYWORD_OR = 71, 
    KEYWORD_ORDERED = 72, KEYWORD_OUT = 73, KEYWORD_PACKAGE = 74, KEYWORD_PORTION = 75, 
    KEYWORD_PREDICATE = 76, KEYWORD_PRIVATE = 77, KEYWORD_PROTECTED = 78, 
    KEYWORD_PUBLIC = 79, KEYWORD_READONLY = 80, KEYWORD_REDEFINES = 81, 
    KEYWORD_REDEFINITION = 82, KEYWORD_REFERENCES = 83, KEYWORD_REP = 84, 
    KEYWORD_RETURN = 85, KEYWORD_SPECILIZATION = 86, KEYWORD_SPECIALIZES = 87, 
    KEYWORD_STEP = 88, KEYWORD_STRUCT = 89, KEYWORD_SUBCLASSIFIER = 90, 
    KEYWORD_SUBSET = 91, KEYWORD_SUBSETS = 92, KEYWORD_SUBTYPE = 93, KEYWORD_SUCCSESSION = 94, 
    KEYWORD_THEN = 95, KEYWORD_TO = 96, KEYWORD_TRUE = 97, KEYWORD_TYPE = 98, 
    KEYWORD_TYPED = 99, KEYWORD_TYPING = 100, KEYWORD_UNIONS = 101, KEYWORD_XOR = 102, 
    KEYWORD_VAR = 103, KEYWORD_LOCALE = 104, KEYWORD_STANDARD = 105, KEYWORD_LIBRARY = 106, 
    KEYWORD_CONSTANT = 107, SINGLE_LINE_NOTE = 108, MULTI_LINE_NOTE = 109, 
    REGULAR_COMMENT = 110, SYMBOL_COMMENT_BLOCK_START = 111, SYMBOL_NOTE_BLOCK_START = 112, 
    SYMBOL_COMMENT_BLOCK_END = 113, SYMBOL_STATEMENT_DELIMITER = 114, SYMBOL_STAR = 115, 
    SYMBOL_NAMESPACE_SUBSET = 116, SYMBOL_TYPED_BY = 117, SYMBOL_SPECIALIZES = 118, 
    SYMBOL_REFERENCES = 119, SYMBOL_REDEFINES = 120, SYMBOL_CONJUNGATES = 121, 
    SYMBOL_ROUND_BRACKET_OPEN = 122, SYMBOL_ROUND_BRACKET_CLOSE = 123, SYMBOL_CURLY_BRACKET_OPEN = 124, 
    SYMBOL_CURLY_BRACKET_CLOSE = 125, SYMBOL_SQUARE_BRACKET_OPEN = 126, 
    SYMBOL_SQUARE_BRACKET_CLOSE = 127, SYMBOL_COMMA = 128, SYMBOL_AT = 129, 
    SYMBOL_HASHTAG = 130, SYMBOL_MOD = 131, SYMBOL_AND = 132, SYMBOL_UPPER = 133, 
    SYMBOL_VERTICAL_LINE = 134, SYMBOL_DOUBLE_STAR = 135, SYMBOL_PLUS = 136, 
    SYMBOL_MINUS = 137, SYMBOL_SLASH = 138, SYMBOL_ARROOW = 139, SYMBOL_DOT = 140, 
    SYMBOL_DDOT = 141, SYMBOL_SMALLER = 142, SYMBOL_SMALLER_EQUAL = 143, 
    SYMBOL_ASSIGN = 144, SYMBOL_DEF_ASSIGN = 145, SYMBOL_EQUALS = 146, SYMBOL_IFF_EQUALS = 147, 
    SYMBOL_NOT_EQUALS = 148, SYMBOL_IFF_NOT_EQUALS = 149, SYMBOL_GREATER = 150, 
    SYMBOL_GREATER_EQUALS = 151, SYMBOL_QUESTION = 152, SYMBOL_DQUESTION = 153, 
    SYMBOL_DOT_QUESTION = 154, NAME = 155, BASIC_NAME = 156, UNRESTRICTED_NAME = 157, 
    DECIMAL_VALUE = 158, EXPONENTIAL_VALUE = 159, STRING_VALUE = 160, WS = 161
  };

  explicit KerMLLexer(antlr4::CharStream *input);

  ~KerMLLexer() override;


  std::string getGrammarFileName() const override;

  const std::vector<std::string>& getRuleNames() const override;

  const std::vector<std::string>& getChannelNames() const override;

  const std::vector<std::string>& getModeNames() const override;

  const antlr4::dfa::Vocabulary& getVocabulary() const override;

  antlr4::atn::SerializedATNView getSerializedATN() const override;

  const antlr4::atn::ATN& getATN() const override;

  // By default the static state used to implement the lexer is lazily initialized during the first
  // call to the constructor. You can call this function if you wish to initialize the static state
  // ahead of time.
  static void initialize();

private:

  // Individual action functions triggered by action() above.

  // Individual semantic predicate functions triggered by sempred() above.

};

